package analizadorLexico;

import java_cup.runtime.*;
import analizadorLexico.backend.*;
import analizadorLexico.sym;
import Node.Nodo;

parser code {:

	public static String CD_ROOT = "/"; //root por defecto
	public static int OPTION_DIRECTORIO = 0;
	public static int OPTION_ARCHIVO = 1;
	private int positionNode = 1; //Posicion de los nodos en el arbol
	private int option = 0; //Directorio = 0, Path = 1
	private String nodoAnterior = "";
	private ManejadorParser mp = null;
	private Nodo nodo = null;



	// Connect this parser to a scanner!
	public parser(Lexer lex, ManejadorParser mp) {
		super(lex);
		this.mp = mp;
		this.nodo = mp.getNodeRoot();
	}

        public void syntax_error(Symbol cur_token) {
            System.out.println("Error sintactico en <" + cur_token.value + ">");
        }
:}

/* Terminals (tokens returned by the scanner). */
terminal String          PWD, LS, LONG, HIDDEN, EXECUTE, WRITE, READ, RECURSIVE;
terminal String          CD, BACK, ACTUAL, TOUCH, MKDIR, MV, CP, VARIOUS, ALL, LONG_HIDDEN;
terminal String          RM, RMDIR, SLASH, AGREGAR, QUITAR, ID, CHMOD, SPACE, EXIT;

/* Non-terminals */
non terminal String         main, main1, main2, main3, space, path, path1, exit;
non terminal String 		pwd, ls, ls1;
non terminal String 		cd, cd1;
non terminal String 		touch, touch1, touch2;
non terminal String 		mv, mv1, mv2, mv3;
non terminal String 		mkdir, mkdir1, p;
non terminal String 		rm, rm1, rm2, rm3;
non terminal String 		cp, cp1, cp2, cp3, cp4, cp5;
non terminal String 		rmdir, rmdir1;
non terminal String 		chmod, chmod1, chmod2, chmod3, chmod4, x, w, r;

/* The grammar */
start with main;


/*==============Gramtica main==============*/
main ::= 	main2
			;

main1 ::=	space
			;

main2 ::= 	pwd
			| exit
			| ls
			| cd
			| touch
			| mv
			| mkdir
			| rm
			| cp
			| rmdir
			| chmod
			;

main3 ::=	space
			;

/*==============Gramtica PWD==============*/

pwd ::= 	PWD {:mp.pwd();:}
			;


/*==============Gramtica LS==============*/
ls ::=		LS space ls1
			| LS:e1 {:mp.ls(0);:}
			;

ls1 ::=		LONG {:mp.ls(1);:}
			| HIDDEN {:mp.ls(2);:}
			| LONG_HIDDEN {:mp.ls(3);:}
			;

/*==============Gramtica CD==============*/

cd ::=		CD space cd1
			| CD {:mp.functionByPath(CD_ROOT, nodo, nodoAnterior, 2);:}
			;

cd1 ::=		BACK {:mp.cdByBack();:}
			| ACTUAL 
			| SLASH {:mp.functionByPath(CD_ROOT, nodo, nodoAnterior, 2);:}
			| path:e1 {:RESULT = e1; mp.functionByPath(RESULT, nodo, nodoAnterior, 2);:}
			;

/*==============Gramtica TOUCH==============*/

touch ::= 	TOUCH {: positionNode = 0; nodoAnterior = null;:} space touch1
			;

touch1 ::= 	touch1 space touch2 
			| touch2
			;

touch2 ::=	ID:e2 {:RESULT = e2; mp.functionById(RESULT, 1);:}
			| path:e1 {:RESULT = e1; mp.functionByPath(RESULT, nodo, nodoAnterior, 1);:}
			; 

/*==============Gramtica MV==============*/
mv ::=		MV space mv1
			;

mv1 ::=		mv2 space mv3
			;

mv2 ::=		path
			| ID
			;

mv3 ::=		mv2
			| ACTUAL
			| BACK
			;

/*==============Gramtica MKDIR==============*/

mkdir ::= 	MKDIR space mkdir1
			;

mkdir1 ::= 	ID:e2 {:RESULT = e2; mp.functionById(RESULT, 0);:} 
			| path:e1 {:RESULT = e1; mp.functionByPath(RESULT, nodo, nodoAnterior, 0);:}
			| p space path
			;

p ::=		VARIOUS
			;

/*==============Gramtica RM==============*/

rm ::=		RM space rm1
			;

rm1 ::=		rm2 space rm3:e1 {:RESULT = e1; if(option == 1){mp.rmById(RESULT, 2);} else {mp.rmdirByPath(nodo, nodoAnterior, 1);}:} 
			| rm3:e1 {:RESULT = e1; if(option == 1){mp.rmById(RESULT, 1);} else {mp.rmByPath(nodo, nodoAnterior);}:}
			;

rm2 ::=		ALL
			;

rm3 ::= 	path:e2 {:RESULT = e2; option = 2;:}
			| ID:e1 {:RESULT = e1; option = 1;:}
			;

/*==============Gramtica CP==============*/

cp ::=		CP space cp1
			;

cp1 ::=		cp2 space cp3
			| cp3
			;

cp2 ::=		ALL
			;

cp3 ::=		cp4 //{:primerNodo = nodo;:} space cp5 {:segundoNodo = nodo;:}
			;

cp4 ::=		path
			| ID
			;

cp5 ::= 	cp4
			;

/*==============Gramtica RMDIR==============*/

rmdir ::= 	RMDIR space rmdir1
			;

rmdir1 ::= 	path {:mp.rmdirByPath(nodo, nodoAnterior, 0);:}
			| ID:e1 {:RESULT = e1; mp.rmById(RESULT, 0);:}
			| ACTUAL
			| BACK
			;

/*==============Gramtica RMDIR==============*/

chmod ::=	CHMOD space RECURSIVE space chmod1
			| CHMOD space chmod1
			;

chmod1 ::= 	chmod2 space chmod3 space chmod4
			;

chmod2 ::=	AGREGAR
			| QUITAR
			;

chmod3 ::= 	r w x
			| w x r
			| x r w 
			| r x w 
			| w r x
			| x w r 
			| r x
			| r w
			| w x 
			| w r 
			| x w 
			| x r
			| x 
			| r
			| w
			;

chmod4 ::=	path
			| ID
			;

x ::= 		EXECUTE
			;

w ::=		WRITE
			;

r ::=		READ
			;

/*==============Gramtica PATH==============*/

path ::= 	path:e1 path1:e2 {:RESULT = e1 + e2;:}
			| path1: e1 {:RESULT = e1;:}
			;

path1 ::= 	SLASH:e1 ID:e2 {:RESULT= e1 + e2;
			nodo = mp.getNode(e2, nodoAnterior, nodo, positionNode, option); positionNode++; nodoAnterior = e2;:}
		;

/*==============Gramtica PATH==============*/

space ::=	space SPACE 
			| SPACE {: positionNode = 1; nodoAnterior = "";:}
			;

/*==============Gramtica PATH==============*/

exit ::=	EXIT {:mp.exit();:}
			;
